# Параллельное программирование



## 1. Необходимость

​	Иногда выгоднее не придумывать алгоритм распараллеливания задачи, а просто купить больше вычислительной мощности. Например, зарплата среднего разработчика на языке C++ составляет около 150 тыс. руб. Если этому разработчику на переделывание системы понадобится больше месяца, мы будем в явном минусе - процессор помощнее стоит дешевле. 

​	Понятно, что иногда нам нужен прирост производительности, который невозможно обеспечить лишь за счет увеличения вычислительной мощности. В таких случаях затраты времени на проработку алгоритма параллельного программирования становятся оправданными.

​	Увеличив число ядер процессора в 10 раз, наивно ожидать прироста производительности в 10 раз. Хотя бы из-за затрат ОС на переключение между потоками. А еще у нас есть последовательный код, который невозможно распараллелить, например, ввод/вывод. Рассмотрим закон Амдала.
$$
S = \frac{1}{\alpha + \frac{1-\alpha}{p}},\space где\space\space
\alpha - доля \space последовательного\space кода,\space p - число\spaceпроцессоров
$$
​	Например, увеличив число процессоров в 10 раз и имея долю последовательного кода 0.2 получим S = 3,6. То есть прирост производительности меньше, чем в 4 раза.  



​	А может просто запустить несколько экземпляров программы на одном компьютере? Тогда и распараллеливать ничего не надо. Можно так сделать, но выгода будет гораздо меньше. Переключение потоков в рамках одного процесса для ОС намного дешевле и быстрее, чем переключение процессов. У ОС есть кэш процессов и при переключении между ними придется все время его обновлять, а при переключении потоков он не меняется.



## 2. Одно ядро

​	Предположим, в нашем процессоре только одно ядро. Можно ли в этом случае говорить о параллельном программировании? Да, поскольку все современные процессоры реализуют SSE (*Streaming SIMD Extensions*)

​	В SSE добавлены шестнадцать 128-битных регистров, которые называются xmm0 —xmm15. Над этими регистрами можно проводить различные математические операции одной процессорной инструкцией. 

​	Например, мы хотим перемножить 2 массива размера 4 поэлементно. В регистр xmm0 записываем весь первый массив, в регистр xmm1 второй массив. Одной инструкцией **mulps** получаем результат.

Более реалистичный пример. Требуется как можно быстрее найти сумму элементов массива `array[100_000]`. Рассмотрим несколько реализаций.

```c#
  public int Simple()
  {
      int sum = 0;
      foreach (var item in array)
      {
          sum += item;
      }
      return sum;
  }

  public int Linq()
  {
      return array.Sum();
  }

 public int Vector()
   {
     int vectorSize = Vector<int>.Count;
     var accVector = Vector<int>.Zero;
     int i;
     for (i = 0; i < array.Length - vectorSize; i += vectorSize)
     {
         var v = new Vector<int>(array, i);
         accVector = Vector.Add(accVector, v);
     }
     int result = Vector.Dot(accVector, Vector<int>.One);
     for (; i < array.Length; i++)
     {
         result += array[i];
     }
     return result;
   }
```

​	Если запустить тест у себя на компьютере, можно убедиться, что реализация через `Vector` работает быстрее.

​	 Платформа .NET предоставляет более низкое управление SSE инструкциями через пространство имен `System.Runtime.Intrinsics`. В нем находятся классы, позволяющие работать напрямую с аппаратным инструкциями разных типов процессоров.

 	Например, для Intel это класс `Avx2`. Классы `Sse`-`Sse4` предназначены для работы с разными версиями SSE. Все методы этих классов работают с структурой `Vector`, пользоваться ими приходится в редких случаях. 









## 3. Примитивы синхронизации







## 4. Алгоритмы синхронизации







## 5. Шаблоны || программирования